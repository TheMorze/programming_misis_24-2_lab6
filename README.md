# Лабораторная работа №6: Паттерн "Стратегия"

## Цель
- Закрепить принципы SOLID (SRP, OCP).
- Реализовать паттерн "Стратегия" на примере алгоритмов сортировки.

## Структура проекта
StrategyPatternLab6/
├── CMakeLists.txt
├── README.md
├── include/
│ ├── SortingStrategy.h
│ ├── Sorter.h
│ ├── BubbleSortStrategy.h
│ ├── QuickSortStrategy.h
│ ├── StdSortStrategy.h
│ └── InsertionSortStrategy.h
└── src/
├── Sorter.cpp
├── BubbleSortStrategy.cpp
├── QuickSortStrategy.cpp
├── StdSortStrategy.cpp
├── InsertionSortStrategy.cpp
└── main.cpp

## Описание классов
- **SortingStrategy** — интерфейс стратегии с методом `sort(std::vector<int>&)`.
- **BubbleSortStrategy**, **QuickSortStrategy**, **StdSortStrategy**, **InsertionSortStrategy** — конкретные стратегии сортировки.
- **Sorter** — контекст, принимает стратегию через конструктор и/или `setStrategy` и выполняет сортировку методом `sortData`.

## Паттерн "Стратегия"
Паттерн «Стратегия» позволяет:
1. Извлечь алгоритм из контекста.
2. Легко добавлять новые алгоритмы без изменения клиентского кода.

## SOLID-принципы
- **SRP (Single Responsibility Principle)**:
  Каждый класс отвечает лишь за одну задачу:
  - стратегии — за сортировку,
  - `Sorter` — за управление выбранной стратегией.
- **OCP (Open/Closed Principle)**:
  Класс `Sorter` «открыт» для расширения (можно передать любую новую стратегию), но «закрыт» для модификации (не требуется менять его код при добавлении новой стратегии).

## Сборка и запуск

bash
mkdir build
cd build
cmake ..
make
./StrategyPatternDemo

## Ожидаемый вывод программы

Original data: 5 2 9 1 5 6
Bubble sorted:   1 2 5 5 6 9
Quick sorted:    1 2 5 5 6 9
Std::sort:       1 2 5 5 6 9
Insertion sort:  1 2 5 5 6 9

## Вывод

В этой лабораторной работе требовалось:

1. **Изучить и применить принципы SOLID**
   - **SRP (Single Responsibility Principle)** — каждый класс/интерфейс должен иметь одну чёткую зону ответственности.
   - **OCP (Open/Closed Principle)** — код должен быть открыт для расширения (новые алгоритмы), но закрыт для модификации (не менять существующий контекст).

2. **Реализовать паттерн «Стратегия»**
   - Создать абстрактный интерфейс `SortingStrategy` с виртуальным методом `sort(std::vector<int>&)`.
   - Сделать класс `Sorter`, который в конструкторе (и через `setStrategy`) принимает любой объект `SortingStrategy` и в методе `sortData` вызывает его `sort`.

3. **Реализовать несколько конкретных стратегий сортировки**
   - **BubbleSortStrategy** — классическая «пузырьковая» сортировка.
   - **QuickSortStrategy** — быстрая сортировка с рекурсивным разделением по опорному элементу.
   - **StdSortStrategy** — обёртка вокруг стандартной `std::sort`.

4. **Проверить соблюдение принципов SRP и OCP**
   - Каждый класс отвечает только за свою часть: стратегии — за алгоритмы сортировки, `Sorter` — за управление стратегией.
   - При добавлении новых стратегий не пришлось менять код `Sorter` или интерфейса — система осталась неизменной, что подтверждает OCP.

5. **Добавить новую стратегию без изменения старого кода**
   - **InsertionSortStrategy** — сортировка вставками, добавленная отдельно, без правок в `Sorter` или `SortingStrategy`.

6. **Организовать сборку и версионирование**
   - Написать `CMakeLists.txt` для автоматизированной сборки проекта.
   - Использовать Git: делать коммиты на каждом этапе (инициализация, добавление интерфейсов, реализация стратегий, новая стратегия, CMake, README).

7. **Подготовить README**
   - Описать структуру проекта, используемые классы и файлы.
   - Пояснить, что такое паттерн «Стратегия» и его преимущества.
   - Рассказать, как соблюдены принципы SOLID.
   - Привести инструкции по сборке и запуску программы, а также пример её вывода.

В результате получилась гибкая и расширяемая система сортировки, где:
- **Гибкость** достигается переключением стратегий в рантайме.
- **Расширяемость** — добавление новой стратегии не требует модификации существующего контекста.
- Все ключевые требования лабораторной работы (паттерн «Стратегия», SOLID, CMake, Git) были выполнены и продемонстрированы.
